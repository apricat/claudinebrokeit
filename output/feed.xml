<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://claudinebroke.it</link>
    <atom:link href="http://claudinebroke.it/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Sat, 30 Apr 2016 21:15:20 +0000</pubDate>
    <lastBuildDate>Sat, 30 Apr 2016 21:15:20 +0000</lastBuildDate>

    <item>
      <title>Petit Workout - The Application</title>
      <link>http://claudinebroke.it/blog/2016/graphics.html</link>
      <pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2016/graphics.html</guid>
      	<description>
	&lt;p&gt;Hello again! Today we&apos;re going to continue working on the little workout application we instigated in my previous blog post. This post will cover the basic concepts behind generating a &lt;em&gt;Graphical User Interface&lt;/em&gt; for a Java application :coffee:&lt;/p&gt;&lt;h3&gt;JavaFX || Swing || AWT&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Swing&lt;/code&gt;, &lt;code&gt;JavaFX&lt;/code&gt; and &lt;code&gt;AWT&lt;/code&gt; are GUI widget toolkits that offer components to allow the interaction between users and applications. Right away we can eliminate &lt;code&gt;AWT&lt;/code&gt; from our potential application toolkit as it directly uses the operating system&apos;s components; meaning that the resulting application will not have the same &lt;em&gt;look and feel&lt;/em&gt; on Ubuntu, Mac and Windows. This leaves us with &lt;code&gt;Swing&lt;/code&gt; and &lt;code&gt;JavaFX&lt;/code&gt; as candidates. Both are valid for our needs, however, Oracle corp. has determined that &lt;code&gt;JavaFX&lt;/code&gt; is set to be replacing &lt;code&gt;Swing&lt;/code&gt; as &lt;em&gt;the&lt;/em&gt; GUI toolkit. This means that it isn&apos;t deprecated as of yet, but is receiving far less attention in the latest Java releases.&lt;/p&gt;&lt;h3&gt;JavaFX Basics&lt;/h3&gt;&lt;p&gt;Here is a simple visual representation of how a basic JavaFX application is structured:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; _____________________
| stage             x |
|  _________________  |
| | scene           | |
| |  _____________  | |
| | | layout pane | | |
| | |  _________  | | |
| | | | button  | | | |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So we need to add components (buttons, labels, graphics, etc.) to a layout, that is set within a scene, that is held within a stage.&lt;/p&gt;&lt;p&gt;In code, it looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class WorkoutQueueTest extends Application {

    private Label timerLabel;

    public static void main(String[] args) throws Exception
    {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception
    {
        primaryStage.setTitle(&amp;quot;Petit Workout&amp;quot;);

        Button startBtn  = new Button(&amp;quot;Start&amp;quot;);
        startBtn.setOnAction((e) -&amp;gt; startWorkout());

        timerLabel = new Label(&amp;quot;00:00:00&amp;quot;);

        BorderPane pane  = new BorderPane();
        pane.setTop(startBtn);
        pane.setBottom(timerLabel);
        primaryStage.setScene(new Scene(pane, 300, 250));

        // @todo add terminate thread on close
        primaryStage.show();
    }

    public void startWorkout()
    {
        AnimationTimer animationTimer = new AnimationTimer() {
            long startTime = System.nanoTime();

            @Override
            public void handle(long now) {
                timerLabel.setText(
                    ReadableTimeConverter.convert(
                        toIntExact(
                            (now - startTime) / 1000000000
                        )
                    )
                );
            }
        };

        animationTimer.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Labels and Buttons&lt;/h3&gt;&lt;p&gt;Components classes offer more than one constructor, meaning that the argument count will determine what funtion is called. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Label timerLabel = new Label();
timerLabel.setText(&amp;quot;00:00:00&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Is the same as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Label timerLabel = new Label(&amp;quot;00:00:00&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is because Java supports classes with multiple constructors, which means that the constructor being called is determined by its signature. This is called &lt;em&gt;overloading constructers&lt;/em&gt;. If we dig a bit deeper, we can see that the &lt;code&gt;Label&lt;/code&gt; class offers three different constructors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Creates an empty label
 */
public Label() {
    initialize();
}

/**
 * Creates Label with supplied text.
 * @param text null text is treated as the empty string
 */
public Label(String text) {
    super(text);
    initialize();
}

/**
 * Creates a Label with the supplied text and graphic.
 * @param text null text is treated as the empty string
 * @param graphic a null graphic is acceptable
 */
public Label(String text, Node graphic) {
    super(text, graphic);
    initialize();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This means that an often used actions such as adding text and graphics to a newly created &lt;code&gt;Label&lt;/code&gt; and &lt;code&gt;Button&lt;/code&gt; objects are accessible through a one-liner method call.&lt;/p&gt;&lt;h4&gt;Buttons and Lambda Event Handling&lt;/h4&gt;&lt;p&gt;Specific to buttons is the possibility to generate event listeners whose methods execute logic based on events and targets. In our case, we want to call upon the &lt;code&gt;startWorkout&lt;/code&gt; method upon button click.&lt;/p&gt;&lt;p&gt;From the Java doc:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;When a button is pressed and released a ActionEvent is sent. Your application can perform some action based on this event by implementing an EventHandler to process the ActionEvent.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;And:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Lambda Expressions enable you to encapsulate a single unit of behavior and pass it to other code. You can use a lambda expressions if you want a certain action performed on each element of a collection, when a process is completed, or when a process encounters an error.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Starting Java 8, you can use anonynous (lambda) functions in your code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;startBtn.setOnAction((e) -&amp;gt; startWorkout());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a much more direct, easy-to-read and elegant way to execute the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;startBtn.setOnAction(new EventHandler&amp;lt;ActionEvent&amp;gt;() {
    @Override
    public void handle(ActionEvent event) {
       startWorkout();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So there&apos;s really no excuse in our case to not opt for the Lambda expression; the resulting smaller code footprint and &lt;em&gt;straight-to-the-point&lt;/em&gt; syntax really improve legibility.&lt;/p&gt;&lt;h3&gt;Layout Panes&lt;/h3&gt;&lt;p&gt;Once we&apos;ve created our buttons and labels, we need to place these on the application window. This is where the JavaFX SDK&apos;s layout container classes, such as &lt;code&gt;BorderPane&lt;/code&gt;, &lt;code&gt;StackPane&lt;/code&gt;, &lt;code&gt;GridPane&lt;/code&gt; and &lt;code&gt;FlowPane&lt;/code&gt;, come to our aid. You can manually lay out UI components by setting their position and size within your JavaFX application. However, using layouts makes it easier - and quicker - to manage the classic cases where you need such common layouts as rows, columns and tiles. It even covers repositioning elements upon window resize operations. Since &lt;em&gt;Petit Workout&lt;/em&gt;, in its current iteration, is quite &lt;em&gt;humble&lt;/em&gt;, we can use the basic &lt;code&gt;BorderPane&lt;/code&gt; layout container, which looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; _______________________
| top                   |
|_______________________|
| left | center | right |
|______|________|_______|
| bottom                |
|_______________________|
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Placing our elements is then as easy as using the &lt;code&gt;set&lt;/code&gt; methods available with the &lt;code&gt;BorderPane&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BorderPane pane = new BorderPane();
pane.setTop(startBtn);
pane.setBottom(timerLabel);
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Scene and Stage -- Or putting it all together&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;primaryStage.setScene(new Scene(pane, 300, 250));
primaryStage.show();
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Timer&lt;/h3&gt;&lt;p&gt;Since we want to be as conservative as possible with thread usage in order to save resources, we can latch on to pre-existing runnable implementations to run a timer that monitors our workout. We can thus instantiate a new &lt;code&gt;AnimationTimer&lt;/code&gt; that is associated to the JavaFX &lt;code&gt;MasterTimer&lt;/code&gt; instance. In effect, this means that our &lt;code&gt;AnimationTimer&lt;/code&gt; events will fire upon ever frame within our JavaFX application, much like the Swing &lt;code&gt;redraw&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long timestampOnInit = System.nanoTime();
AnimationTimer animationTimer = new AnimationTimer() {
    @Override
    public void handle(long now) {
        timerLabel.setText(
            ReadableTimeConverter.convert(
                toIntExact((now - timestampOnInit) / 1000000000)
            )
        );
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In effect, upon each frame execution, compare the current timestamp with the one we captured upon &lt;em&gt;start&lt;/em&gt; button press. The resultant timestamp is afterward used to update our application&apos;s timer label with the elapsed time value converter as a &lt;code&gt;ReadableTimeConverter&lt;/code&gt; value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReadableTimeConverter {

    /**
     * @param seconds
     * @return String
     */
    public static String convert(int seconds)
    {
        int hr  = seconds / 3600;
        int rem = seconds % 3600;
        int mn  = rem / 60;
        int sec = rem % 60;

        return (hr &amp;lt; 10 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;) + hr + &amp;quot;:&amp;quot; + (mn &amp;lt; 10 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;) + mn + &amp;quot;:&amp;quot; + (sec &amp;lt; 10 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;) + sec;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The advantage with this solution is that we are never dependent upon the CPU cycle&apos;s &lt;em&gt;idea&lt;/em&gt; of a timestamp. If we were to instantiate a &lt;code&gt;runnable&lt;/code&gt; instance set to execute, for example, every second, after some time we would start to see pretty severe discrepencies between our application&apos;s time and real time. This is because scheduled &lt;code&gt;runnable&lt;/code&gt; tasks are dependent upon the CPU cycle&apos;s time. This can manifest in slower or faster times. So you could be, without knowing it, working out for a mear 40 minutes instead of a full 45; which is &lt;em&gt;unacceptable&lt;/em&gt; ;)&lt;/p&gt;&lt;h3&gt;Closing Statement&lt;/h3&gt;&lt;p&gt;So this brings us a little closer to a fully working workout application. In the next blog post we&apos;ll integrate our &lt;code&gt;producer-consumer&lt;/code&gt; thread pattern and add a countdown and intensity label to the GUI :excited:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;As always, the code related to this blog post is available on my &lt;a href=&quot;https://github.com/apricat/petitworkout&quot;&gt;GitHub account&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
	</description>
    </item>
    <item>
      <title>Favorite Soup II</title>
      <link>http://claudinebroke.it/blog/2016/favorite-soup-II.html</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2016/favorite-soup-II.html</guid>
      	<description>
	&lt;h2&gt;Leek, Turnip and Rice Soup&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Time: 45 minutes&lt;/em&gt;&lt;/p&gt;&lt;p&gt;I&apos;ve been battling a bit of a cold lately, and nothing makes me happier than warm, fagrant soup when I feel like this.&lt;/p&gt;&lt;p&gt;If you&apos;re a normal human being, then you used to hate turnip as a kid. When I saw the original recipe, I focused solely on the leeks and rice, and my brain completely made abstraction of the root vegetable required. This until I hit the grocery store aisle and ended up with the unsightly blob in my hand, and that is where I decided to give it a try. I &lt;em&gt;did&lt;/em&gt; change my mind about brussel sprouts this year, so I decided to give turnips a try as an adult. I&apos;m so glad I did! I owe my mom an apology, &lt;em&gt;turnips aren&apos;t so bad&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Adapted from the &lt;a href=&quot;http://cooking.nytimes.com/recipes/12179-leek-turnip-and-rice-soup&quot;&gt;New York Times&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;h3&gt;Ingredients&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1 tablespoon extra virgin olive oil&lt;/li&gt;
  &lt;li&gt;3 large leeks, white and green parts, cleaned and sliced&lt;/li&gt;
  &lt;li&gt;1 small turnip, sliced in 1/2 inch cubes&lt;/li&gt;
  &lt;li&gt;2 garlic cloves, minced&lt;/li&gt;
  &lt;li&gt;6 cups water&lt;/li&gt;
  &lt;li&gt;1 vegetable bouillon cube&lt;/li&gt;
  &lt;li&gt;salt and pepper&lt;/li&gt;
  &lt;li&gt;1 bay leaf&lt;/li&gt;
  &lt;li&gt;1/2 cups of long brown rice&lt;/li&gt;
  &lt;li&gt;2 handfuls of fresh italian parsley, chopped&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Preparation&lt;/h3&gt;&lt;p&gt;On medium, heat the oil in a large soup pot and add leek slices. Cook until the leeks begin to soften and add turnip. Stir often and cook for about 5 more minutes, or until leeks are fragrant and turnips are translucent. Add salt, pepper and garlic, cook for another minute. Add water, stock, bay leaf and rice. Set kitchen timer to 30 minutes, reduce heat to low, and go watch some netflix. Add fresh parsley to soup before serving.&lt;/p&gt;&lt;h3&gt;Notes&lt;/h3&gt;&lt;p&gt;I usually start by slicing the leek. Then, while the leek is softening in the pot, I cube the turnip. On the side, I also boil the required 6 cups of water in my electric kettle to speed up the soup making process.&lt;/p&gt;&lt;p&gt;Also, Leek and Turnip are best bought, in Quebec, in winter: &lt;a href=&quot;https://www.mapaq.gouv.qc.ca/fr/Publications/FruitsetLegumesduquebec.pdf&quot;&gt;calendar&lt;/a&gt; (fr)&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Petit Workout Queue</title>
      <link>http://claudinebroke.it/blog/2016/petitworkout.html</link>
      <pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2016/petitworkout.html</guid>
      	<description>
	&lt;p&gt;Snow is clearing out, maple syrup is flowing, and the birds are coming back; spring is finally here! This means I&apos;ll soon be back on my bike exploring all the amazing land accessible on two wheels - yay! I can&apos;t even count how many how many boring hours I&apos;ve spent on my stationary bike this winter trying to maintain my stamina, cardio and muscle. Now&apos;s the time to kick it up a notch, though, and maximize all these remaining living room workouts in order to be in the best shape possible when I hit the streets.&lt;/p&gt;&lt;p&gt;A great way to maximize workouts is to do interval training, i.e. executing series of exercises at difference intensity levels. I tried doing so using my phone&apos;s stopwatch, but sweat and phone don&apos;t match too well. Besides, how else was I going to learn Java? So I started building my own little workout application.&lt;/p&gt;&lt;h3&gt;Petit Workout&lt;/h3&gt;&lt;p&gt;The way our workouts (yes, now it is -our- workout) are to be structured is quite easy; each &lt;em&gt;workout&lt;/em&gt; contains a series of &lt;em&gt;intervals&lt;/em&gt; at specific &lt;em&gt;intensity&lt;/em&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Workout example #1

+----+-----------+-----------+
|    |  Duration | Intensity |
+----+-----------+-----------+
|  0 |      6000 | &amp;quot;easy&amp;quot;    |
|  1 |      1000 | &amp;quot;hard&amp;quot;    |
|  2 |      3000 | &amp;quot;easy&amp;quot;    |
+----+-----------+-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we are to focus on the individual intervals, we get objects like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Interval {

    private String intensity;
    private long duration;

    public Interval(String intensity, long duration) 
    {
        this.intensity = intensity;
        this.duration  = duration;
    }

    @Override
    public String toString() 
    {
        return &amp;quot;Interval{&amp;quot; +
            &amp;quot;intensity=&amp;#39;&amp;quot; + intensity + &amp;#39;\&amp;#39;&amp;#39; +
            &amp;quot;, duration=&amp;quot; + duration +
            &amp;#39;}&amp;#39;;
    }

    public String getIntensity() 
    {
        return intensity;
    }

    public long getDuration() 
    {
        return duration;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, our &lt;code&gt;Interval&lt;/code&gt; object is a quite basic data struture with getters to retrieve the &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;duration&lt;/code&gt; of our &lt;code&gt;Interval&lt;/code&gt; when needed. For our current iteration of the project, we&apos;re also implementing an &lt;code&gt;@Override&lt;/code&gt; of the &lt;code&gt;Object&lt;/code&gt; &lt;code&gt;toString()&lt;/code&gt; method to cleanly format output during tests. Note that in Java, every class has the &lt;code&gt;Object&lt;/code&gt; class as a superclass, all objects implement the methods of this class, including &lt;code&gt;toString()&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Now back to our &lt;em&gt;series&lt;/em&gt;; one concept to extract from the table provided above is that we are effectively wanting to build a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;intervals&lt;/code&gt;. From the Java Api documentation: &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;A collection represents a group of objects, known as its elements.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;That&apos;s pretty abstract, but also on point; a &lt;code&gt;Collection&lt;/code&gt; is a &lt;code&gt;group&lt;/code&gt; of &lt;code&gt;objects&lt;/code&gt;. Defining an abstract concept allows us to narrow down on specific implementations that may better meet our application needs. In this case, &lt;code&gt;Queues&lt;/code&gt;, which implement the &lt;code&gt;Collection&lt;/code&gt; interface, seeem to fit the bill as they order elements in a FIFO (first-in-first-out) manner -- &lt;em&gt;note that there are some exceptions to this ordering, like &lt;code&gt;Priority queues&lt;/code&gt;, which we won&apos;t discuss as this is outside our project&apos;s scope&lt;/em&gt;. &lt;/p&gt;&lt;p&gt;In this little workout sequencing application, once an interval has terminated its execution, i.e. when its fulfilled its duration time, the application needs to initiate the next interval available in the queue.&lt;/p&gt;&lt;h3&gt;Queue&lt;/h3&gt;&lt;p&gt;There are many types of queuing patterns available through the Java API &lt;code&gt;Collection&lt;/code&gt; interface. One of these concrete implementations is the &lt;code&gt;LinkedList&lt;/code&gt;, which can be used to store and retrieve elements in a list&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Note that Arrays, in Java, are reserved for primative types like integers, doubles, booleans, etc. and not objects, which include strings.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Here is an example of how we can use a &lt;code&gt;LikedList&lt;/code&gt; as a &lt;code&gt;Queue&lt;/code&gt; to generate our workout:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.LinkedList;

public class Queue {
    private LinkedList&amp;lt;Interval&amp;gt; intervalQueue = new LinkedList&amp;lt;&amp;gt;();

    public synchronized void put(Interval interval)
    {
        System.out.println(&amp;quot;Queuing: &amp;quot; + interval);

        intervalQueue.addLast(interval);
        notifyAll();
    }

    public synchronized Interval take()
    {
        while (intervalQueue.size() == 0)
        {
            try
            {
                wait();
            }
            catch (InterruptedException e) {}
        }
        return intervalQueue.removeFirst();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Three important concepts to extract from this class are that:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;p&gt;Interacting with a &lt;code&gt;LinkedList&lt;/code&gt; implementation that contains &lt;code&gt;Interval&lt;/code&gt; objects (&lt;code&gt;LinkedList&amp;lt;Interval&amp;gt;&lt;/code&gt;) effectively guarantees that we can call the &lt;code&gt;getDuration&lt;/code&gt; and &lt;code&gt;getIntensity&lt;/code&gt; methods on the queue&apos;s &lt;code&gt;take&lt;/code&gt; return object.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;As we are going to implement multiple threads in our application, we need to assure no &lt;code&gt;concurrency issues&lt;/code&gt; arise. Since the &lt;code&gt;LinkedList&lt;/code&gt; implementation supplied by the Java Api is not &lt;code&gt;synchronized&lt;/code&gt;, we may face conflicts if more than one thread attempts to access the list at the same time. The &lt;code&gt;synchronized&lt;/code&gt; keyword tells the Java Virtual Machine to &lt;em&gt;lock&lt;/em&gt; an object while it is being accessed by a thread, and to persist this &lt;em&gt;lock&lt;/em&gt; until the first thread is finished with the object.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;A thread attempting to extract a value from the queue while the latter is empty will &lt;code&gt;wait&lt;/code&gt; until an item is added. Also, when the thread attempting to remove an item from the buffer, it notifies other threads to let them know a new element is available for processing.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Now to interact with our queue! We need methods that &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt; items to-and-from the list. There&apos;s actually a well know pattern for that: the &lt;code&gt;Producer-Consumer&lt;/code&gt; pattern. &lt;/p&gt;&lt;p&gt;From Wikipedia:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The [Producer-Consumer] problem describes two processes [...] who share a common, fixed-size buffer used as a queue. The producer&apos;s job is to generate a piece of data, put it into the buffer and start again. At the same time, the consumer is consuming the data (i.e., removing it from the buffer) one piece at a time. The problem is to make sure that the producer won&apos;t try to add data into the buffer if it&apos;s full and that the consumer won&apos;t try to remove data from an empty buffer.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;In other words, a &lt;em&gt;Producer&lt;/em&gt; is a &lt;code&gt;thread&lt;/code&gt; that produces new objects intended to be inserted into a queue, and a &lt;em&gt;Consumer&lt;/em&gt; is the &lt;code&gt;thread&lt;/code&gt; that processes the queued objects.&lt;/p&gt;&lt;h3&gt;Producer&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Producer implements Runnable {

    protected Queue queue;

    public Producer(Queue queue) {
        this.queue = queue;
    }

    public void run() {
        queue.put(new Interval(&amp;quot;easy&amp;quot;, 6000));
        queue.put(new Interval(&amp;quot;hard&amp;quot;, 1000));
        queue.put(new Interval(&amp;quot;easy&amp;quot;, 3000));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Consumer&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Consumer implements Runnable {

    protected Queue queue;

    public Consumer(Queue queue) {
        this.queue = queue;
    }

    public void run() {
        while (true) { consume(queue.take()); }
    }

    void consume(Interval x) {
        System.out.println(&amp;quot;Pulling: &amp;quot; + x);
        try {
            Thread.sleep(x.getDuration());
        }
        catch (InterruptedException e) {}
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;** note the dependency injection of the &lt;code&gt;queue&lt;/code&gt; thread upon the &lt;code&gt;Producer&lt;/code&gt; and &lt;code&gt;Consumer&lt;/code&gt; objects. This is how the two classes communicate with each other.&lt;/p&gt;&lt;h3&gt;Testing&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class QueueTest {

    public static void main(String[] args) throws Exception {

        Queue queue = new Queue();

        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        new Thread(producer).start();
        new Thread(consumer).start();

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, this is a pretty rudamentary implementation. The &lt;code&gt;Producer&lt;/code&gt; class places elements unto the queue, which the &lt;code&gt;Consumer&lt;/code&gt; &quot;takes&quot; out of the queue. The &lt;code&gt;Consumer&lt;/code&gt; does not take subsequent &lt;code&gt;Interval&lt;/code&gt; objects until it has terminated a &lt;code&gt;sleep()&lt;/code&gt; method with a duration &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Queuing: Interval{intensity=&amp;#39;easy&amp;#39;, duration=6000}
Queuing: Interval{intensity=&amp;#39;hard&amp;#39;, duration=1000}
Queuing: Interval{intensity=&amp;#39;easy&amp;#39;, duration=3000}
Pulling: Interval{intensity=&amp;#39;easy&amp;#39;, duration=6000}
Pulling: Interval{intensity=&amp;#39;hard&amp;#39;, duration=1000}
Pulling: Interval{intensity=&amp;#39;easy&amp;#39;, duration=3000}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And that&apos;s that! Next up we will try to add a fun GUI :)&lt;/p&gt;
	</description>
    </item>

  </channel> 
</rss>
